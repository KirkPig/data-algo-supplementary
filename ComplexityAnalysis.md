# Complexity Analysis

 - [สไลด์](https://www.cs.upc.edu/~jordicf/Teaching/FME/Informatica/pdf/Complexity.pdf) ที่หาเจอใน Google
## การวัดประสิทธิภาพของโปรแกรม
การวัดว่าโปรแกรมเก่งเจ๋งขนาดไหน มีปัจจัยหลายอย่างมาก
สำหรับ Competitive Programming ในแต่ละ testcase ภายใต้ input ตามเงื่อนไขที่กำหนด โปรแกรมจะถูกคาดหวังให้
 - print output ออกมาได้ (โปรแกรมไม่ค้าง) และถูกต้อง
 - ใช้ **เวลา (time)** และ **หน่วยความจำ (memory)** ไม่เกินกว่าที่กำหนด
 
 ดังนั้นเราเลยวัดประสิทธิภาพโปรแกรมตาม time/memory ที่โปรแกรมใช้ แต่ปัญหาก็คือ เราวัดค่าพวกนี้ตรง ๆ (โดยเฉพาะเวลา) จากโค้ดของเรายาก เพราะว่ามีปัจจัยเยอะ เช่น Hardware ไม่ว่าจะเป็น RAM หรือ CPU เปลี่ยน เวลาก็เปลี่ยนแล้ว หรือต่อให้ Hardware รุ่นเดียวกัน ลองรัน 2 รอบเวลายังต่างกันเลย

### แล้วเราวัดยังไงกันแน่?
ปกติแล้ว ตอนเราออกแบบอัลกอริทึม เราจะไม่วัดประสิทธิภาพโดยตรง แต่จะดูจากสิ่งที่เรียกว่า ***ความซับซ้อน (Complexity)*** ของโปรแกรมของเรา ซึ่งตัวที่ใช้บ่อย ๆ เวลาทำโจทย์จะมีหลัก ๆ 2 ตัวคือ Big-O Notation กับ Big-Theta $(\theta)$ Notation (แล้วในบทความนี้ก็จะมีแค่ 2 ตัวนี้แหละ เพราะลืมตัวอื่นหมดแล้ว)
## Complexity
ลองดูโค้ดข้างล่างนี้

    int triangle_number(int n) {
	    int sum = 0;
		for (int i = 1; i <= n; i++) {
			sum += i;
		}
		return sum;
	}
ใช่แล้ว ข้างบนนี้คือฟังก์ชันหาผลรวมของจำนวนเต็มตั้งแต่ 1 ถึง n และสามารถเขียนเป็น `return n * (n + 1) / 2` ได้เลย แต่ว่านี่ไม่ใช้ประเด็นที่เราจะคุยกันวันนี้

สำหรับโค้ดข้างต้น จะเห็นเราจะเข้าลูปเป็นจำนวน n รอบ ตามค่าของ n ที่รับเข้ามาในฟังก์ชัน ดังนั้น ถ้าเรากำหนดให้ $T(n)$ เป็นเวลาที่ใช้เมื่อ $n$ หมายถึง parameter ของฟังก์ชัน เราจะเขียนออกมาได้ว่า
> $T(n) = cn + b$ 

เมื่อ $c$ เป็นค่าเฉลี่ยลูปแต่ละรอบ ส่วน $b$ เป็นเวลาจิปาถะที่เกิดจากการประกาศตัวแปร การสร้างลูป การ return ฯลฯ 

เวลาจะวัดประสิทธิภาพของโค้ดเรา เราก็จะลองหาฟังก์ชันเวลาของโปรแกรมเราก่อน ซึ่งถ้าเราสร้างฟังก์ชันเวลาแบบนี้ได้ ชีวิตก็จะดี แล้วเราก็สามารถใช้ $\theta$ ในการคุยกันได้ 

โดย Big-Theta ($\theta$) Notation ของฟังก์ชันใด ๆ  ถ้าพูดภาษาบ้าน ๆ ก็คือ พจน์ที่โตที่สุดเวลาค่าเยอะ ๆ ในฟังก์ชันนั้น โดยที่ไม่คิดสัมประสิทธิข้างหน้า เช่น 
$T(n) = cn + b$  มี 2 พจน์คือ $cn$ กับ $b$ 
สำหรับ $b$ ต่อให้ค่า $n$ เพิ่มเท่าไหร่มันก็ไม่โตแล้ว แต่ $cn$ ยังโตได้เรื่อย ๆ ตามค่า $n$ ดังนั้นพจน์ $cn$ โตมากกว่า เราจึงได้ว่า $T(n) = \theta(n)$  
#### ตัวอย่างอื่น ๆ
สมมติว่า $T(x) = c_1x^2 +c_2x + b$ เราจะได้ว่า $T(x) = \theta(x^2)$ 

กรณีมีหลายตัวแปร เช่น $T(x, y) = c_1x^2 + c_2y$ เราจะได้ว่า $T(x, y) = \theta(x^2 + y)$ เพราะว่า $x$ กับ $y$ ไม่ขึ้นต่อกัน เป็นตัน

**คำถาม:** ฟังก์ชันด้านล่างนี้เป็น $\theta$ อะไร

    \\สมติว่าเราใช้ triangle_number ข้างบน
    int func(int n) {
	    int total = 0;
	    for (int i = 1; i <= n; i++) {
		    total += trianble_number(i);
	    }
    }
**คำตอบ:** $\theta(n^2)$
### คำถามชวนคิด: ทำไมเราถึงนิยมใช้ $\theta$ 

พิจารณา 2 ฟังก์ชันด้านล่าง

    int loop_2n(int n) {
	    int sum = 0;
	    for (int i = 1; i <= 2 * n; i++) {
		    sum += rand() + 4; //บวกเลขแบบสุ่ม
	    }
	    return sum;
    }
	
	int loop_n_with_mod(int n) {
		int sum = 0;
		for (int i = 1; i <= n; i++) {
			sum += rand() % 1234;
		}
	}
ค่อนข้าง Obvious ว่าทั้ง 2 อันเป็น $\theta(n)$ ทั้งคู่ แต่ว่าลูปอันหนึ่งวนถึง $2n$ รอบ ในขณะที่อีกลูปวนเพียง $n$ รอบ ทำให้หลายคนอาจมองว่าลูปล่างควรจะเร็วกว่า แต่ว่าในความเป็นจริงแล้วอาจจะไม่เป็นอย่างนั้นก็ได้ เพราะว่า operation modulo ทำงานช้ากว่า operation บวก พูดง่ายๆ ก็คือเราไม่รู้ว่า constant ที่คูณหน้าตัวแปรเป็นอะไร ดังนั้นเราเลยมักจะพูดถึงแค่ $\theta$ ของฟังก์ชันเท่านั้น

ทุกอย่างเหมือนจะ Happy ending เราไม่ต้องกังวลเรื่อง constant แล้ว ก็น่าจะเพียงพอแล้ว...รึเปล่า
**Spoiler: ไม่**
## ฟังก์ชันที่หา $\theta$ ไม่ได้ และ Big-O
พิจารณาโค้ดข้างล่าง

    bool lucky (int n) {
	    for (int i = 1; i <= n; i++) {
			if (rand() == 99) {
				return true;
			}
		}
		return false;
    }
**คำถาม:** ฟังก์ชันเวลาของเรามีหน้าตาอย่างไร
**คำตอบ:** ...
ถ้าคุณเชื่อว่าคุณดวงดีพอแล้วจะสุ่มเจอ 99 ตั้งแต่รอบแรกทุกครั้ง ก็จะเป็น $\theta(1)$ 
 **Note:** $\theta(1)$ ก็คือ เวลาของเราไม่แปรผันกับตัวแปรอะไร
แต่ถ้าคุณเชื่อว่าคุณไม่มีโชค ต้องเจอรอบที่ n ตลอด ฟังก็ชันก็จะเป็น $\theta(n)$ 
สรุปก็คือเราไม่สามารถหาฟังก์ชันเวลาที่แน่นอนให้กับฟังก์ชันนี้ได้ เราเลยต้องหาวิธีอื่นมาประเมินฟังก์ชันนี้
### งั้นเรามาหา worst case ดีกว่า
ในเมื่อเราหา $\theta$ ไม่ได้ เราก็เลยมาลองพิจารณา Worst case ดีกว่า เช่น ในกรณีนี้ เคสที่เลวร้ายที่สุดของเราคือ
>$T(n) = cn + b$ 

ก็คือเมื่อเราสุ่มไม่เจอ 99 แล้วทำลูปจนครบ
ซึ่ง Big-O ของฟังก์ชันเรา ถ้าพูดภาษาบ้าน ๆ ก็คือ ฟังก์ชันที่พอค่าเยอะ ๆ แล้วจะไม่เล็กกว่าพจน์ที่ใหญ่ที่สุดของเรา แบบตัดสัมประสิทธิ์ออก ดังนั้น ในกรณีข้างบน ตัวใหญ่สุดก็คือ $cn$ เลยได้ว่า $T(n) = O(n)$ 
แต่ว่าถ้าเราอยากเขียนว่า $T(n) = O(n ^2)$ ก็ไม่ผิดเหมือนกัน เพราะว่าพอค่าเยอะ ๆ $n^2$ ก็เป็นฟังก์ชันที่มีค่าไม่น้อยกว่า $n$ เช่นเดียวกัน แต่ปกติแล้วเวลาเราจะพูดถึง $O$ ของโค้ด เราจะพยายาม bound ลงมาให้เป็นฟังก์ชันที่เล็กที่สุดเท่าที่เป็นไปได้

#### ตัวอย่างเพิ่มเติม 
 [พิจารณา Bubble sort แบบล่าง (Optimized) ใน wiki](https://en.wikipedia.org/wiki/Bubble_sort#Implementation)
 **คำถาม:** อัลกอที่ให้ดูมี Big-O เป็นเท่าไหร่ (ลองทำดูเองก่อนค่อยดูคำตอบนะครับ)

<details>
<summary> คำตอบ:

เราจะเห็นว่ากรณีเลวร้ายที่สุดคือลิสต์ของเราเรียงกลับด้าน ทำให้เราต้องไล่ลูปรวมกัน $1 + 2 + ... + (n - 2) + (n - 1)$ ครั้ง เลยมี $O$ เป็น $O(n ^ 2)$


## แบบฝึกหัดเพิ่มเติม
สามารถลองไปทำแบบฝึกหัดเพิ่มเติมได้ [ที่นี่](https://www.geeksforgeeks.org/practice-questions-time-complexity-analysis/)

## การประยุกต์ใช้กับโจทย์
ปกติแล้วถ้าสังเกตดี ๆ เราจะเห็นว่า $\theta(f(n))$ ก็เป็น $O(f(n))$ เช่นเดียวกัน ปกติเราเลยมักพูดถึง $O$ มากกว่า แล้วก็เวลาพูดถึงความซับซ้อนของเวลาเราจะเรียก time complexity ส่วนของหน่วยความจำจะเรียก memory complexity

สำหรับหน่วยความจำ เราจะพอเดาได้ว่า constant ข้างหน้าฟังก์ชันเราควรจะเป็นอะไร เราก็จะพอประมาณได้ว่า worst case ใช้ความจำเท่าไหร่ แต่สำหรับเวลา จริง ๆ แล้วไม่มีสูตรแน่นอนเท่าไหร่ในการประมาณว่า $O(n)$ อันนี้จะรันกี่วินาที เพราะว่าแต่ละ operation มีความเร็ว/ช้าต่างกัน แต่ปกติแล้ว คนแต่งโจทย์มักจะมี $O$ ในใจอยู่แล้ว ซึ่งปกติถ้าเขียน $O$ ได้ไม่แย่ไปกว่าที่คนแต่งคิด และไม่ได้เขียนแย่จนเกินไป เช่นไล่อาเรย์แบบไม่เอื้อต่อ caching หรือใช้ operation modulo หรือหารเยอะ ๆ ก็จะผ่าน ปกติเราเลยสามารถพอลองทดสอบบนเกรดเดอร์ได้ว่า ด้วย Big-O ประมาณนี้จะใช้เวลาประมาณไหน
  
  ### ประสบการส่วนตัว
  จากประสบการส่วนตัว สำหรับเกรดเดอร์ปกติ ผมจะประมาณเวลาว่า สำหรับ operation เฉลี่ย ๆ ค่าใน Big-O ไม่ควรเกิน $10^8$ ถึง $2 \cdot 10^8$ต่อวินาทีเช่น สมมติว่าโค้ดรันใน $O(n \cdot m)$ แล้วให้เวลา 1 วินาที ค่า $n \cdot m$ ที่โจทย์กำหนด ไม่ควรเกิน $10^8$ หรือเต็มที่ก็ $2 \cdot 10^8$ แต่ว่าถ้า operation เร็วมาก ๆ อาจจะสามารถเพิ่มได้ แต่ถ้าใช้หาร modulo หรือ if...else เยอะ ๆ อาจจะช้ากว่านั้นเป็นต้น  
สุดท้ายนี้ ปกติแล้วเวลาแข่งขันจะมีให้ทดลองระบบก่อน ควรทดลองเพื่อที่จะประมาณความเร็วของเกรดเดอร์ได้ด้วย

## คำเตือน
สุดท้ายแล้วการหา $\theta$ หรือ $O$ ของฟังก์ชัน ก็เป็นแค่การวิเคราะห์อัลกอริทึมของโค้ดเรา หลาย ๆ อัลกอริทึมที่ $O(n)$ ก็อาจจะมีการทำงานจริงที่น้อยกว่านั้นมาก ๆ เช่น

    // n <= 10'000
    int birthday_paradox(int n) { 
	    bool found[n];
		for (int i = 0; i < n; i++)
			found[i] = false;
		for (int i = 1; i <= n; i++) {
			int x = rand() % n;
			if (found[x]) return i;
			found[x] = true; 
		}
		return n + 1;
	}
โค้ดดังกล่าวคือการสุ่มค่าไม่เกิน n จนกว่าจะเจอตัวซ้ำ ซึ่งถ้า bound จะได้ว่า worst case จะต้องใช้ n + 1 ครั้ง แต่ว่า...ลองรันดูแล้วคุณจะได้เห็นอะไรบ้างอย่าง (อย่าลืมเปลี่ยน seed random ด้วยนะครับ)
ถ้าลองรันดูจะพบว่าแทบไม่มีครั้งไหนไปถึง n เลยจริง ๆ แล้วจะจบเร็วกว่านั้นมาก ๆ เพราะฉนั้น เราสามารถใช้มันวิเคราะห์ได้ แต่อย่ายึดติดมากเกินไป ควรคำนึงถึงปัจจัยอื่น ๆ ด้วย

## เพิ่มเติม
สำหรับคำนิยามเต็ม ๆ ของ Big-O Notation และ Big-Theta Notation สามารถหาใน Google ได้นะครับ อาจจะทำให้เก็ตขึ้น
 

